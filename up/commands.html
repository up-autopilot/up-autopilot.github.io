<!DOCTYPE html>
<html>
  <head>
    <meta charset='utf-8'>
    <meta http-equiv="X-UA-Compatible" content="chrome=1">
    <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
    <link href='https://fonts.googleapis.com/css?family=Roboto' rel='stylesheet' type='text/css'>
    <link rel="stylesheet" type="text/css" href="../stylesheets/stylesheet.css" media="screen">
    <link rel="stylesheet" type="text/css" href="../stylesheets/github-light.css" media="screen">
    <link rel="stylesheet" type="text/css" href="../stylesheets/print.css" media="print">
    <script src="/javascripts/html-include.js"></script>

    <!--[if lt IE 9]>
    <script src="//html5shiv.googlecode.com/svn/trunk/html5.js"></script>
    <![endif]-->

    <title>Commands - Up</title>
  </head>

  <body>
    <header>
      <div class="inner">
        <h1>Commands</h1>
        <h2>The Modular Framework for Creating Autopilot Solutions</h2>
        <a href="https://github.com/up-autopilot/up" class="button"><small>Follow me on</small> GitHub</a>
      </div>
    </header>

    <div id="content-wrapper">
      <div class="inner clearfix">
        <section id="main-content">
          <h2>Gain Control of Everything</h2>
          <p>
            The Command is a JSON message passed between the components of the
            <strong>Up</strong> application. Their basic structure is following:
          </p>
          <pre>
{
  "name": "name.of.the.command",
  "id": "unique ID",
  "data": {
    // content depends on the command type
  }
}</pre>
          <p>
            The <code>name</code> is a identifier of the command class and
            should be unique within the application. It might be useful to use
            hierarchical names for example <code>telemetry.update</code> or
            <code>telemetry.frequency</code>. This commands are
            <strong>delivered</strong> by the Commands Executor based on the
            value of this field.
          </p>
          <p>
            The <code>id</code> is generated by the <strong>Up</strong> and is
            used to identify the commands, for purposes of detecting
            duplicates, etc.
          </p>
          <p>
            The <code>data</code> can contain any valid JSON object. It's up
            to you what data the command of particular type will carry.
          </p>
          <h3>Methods</h3>
          Each command has the following methods.
          <h4>Properties</h4>
          <p>
            The command has property and property setter for each of the
            <code>name</code>, <code>id</code> and<code>data</code>.
            All of these can be set also in the via the <pre>super.__init__(self, name, data=None, id=str(uuid.uuid1()))</pre>
          </p>
          <h4>Serialization</h4>
          <p>
            The command can be serialized via the:
          </p>
          <pre>
cmd.serialize() <span class="comment"># cmd is the instance of a command</span></pre>
          <p>
            Which returns the string encoded as <strong>utf-8</strong>.
          </p>
          <p>
            You can also deserialize the command from the JSON via the:
          </p>
          <pre>cmd = BaseCommand.from_json(json_str)</pre>
          <p>
            You can use this for example when receiving commands via a Socket.
            After receiving of the JSON, you create a command and than invoke
            the:
          </p>
          <pre>up.commands_receiver.execute_command(cmd)</pre>
          <p>
            Note, that the commands might originate from you application
            and might be used for example for communication between modules.
          </p>
          <h2>Command Handlers</h2>
          <p>
            The Command Handlers are classes which are responsible for
            processing the received command. An instance of this class is
            passed while registering for a command. Once the command has been
            published, the <code>run_action</code> of the handler is invoked.
          </p>
          <p>
            The skeleton of the Command Handler is following:
          </p>
          <pre>
class CommandHandler(BaseCommandHandler):
    def __init__(self):
        super().__init__()

    def run_action(self, command):
        pass</pre>
          <h2>Creation of Commands</h2>
          <p>
            The <strong>Up</strong> has a creator for Commands and Command Handlers
            which is invoked by:
          </p>
          <pre>up create handler &lt;OPTIONS&gt;</pre>
          <p>
            This call creates a file, with Command and Command Handler class. Supported options are:
          </p>
          <ul>
            <li><code>--name/-n</code> - name of the python class, for example <strong>TelemetryUpdate</strong></li>
            <ul>
              <li>
                ommit the 'Command' and 'CommandHandler' in the name, it will be added automatically
              </li>
            </ul>
            <li><code>--identifier/-i</code> name of the command, which will be used in its JSON representation, for example <strong>telemetry.update</strong></li>
          </ul>
          <h2>Processing commands</h2>
          Once the command has been published, the <code>run_action(self, command)</code>
          will be invoked on all registered handlers. The <code>command</code>
          argument contains the published command. See the example in the
          <a href="getting_started.html#processing-command">Getting Started</a>.
          <h2>Threading</h2>
          All commands which are executed by the Command Executor are being
          executed on the <strong>main thread</strong>, no matter the thread which produces them.
          Keep this in mind when designing your modules and handlers.
          <h2>Overriding</h2>
          <p>
            Unlike the modules, you can
            modify the arguments of the <code>__init__</code> of both Command
            and Command Handler. Just do not forget to call the
            <code>super().__init__()</code>. In case of Command you can add
            the args which will be for example used in the data field. In case
            of Command Handler you might add a callback object
            or anything else which you find necessary.
          </p>
        </section>
        <div w3-include-html="../menu.html"></div>
        <script>
        w3IncludeHTML();
        </script>
      </div>
      <footer>This page was generated by <a href="https://pages.github.com">GitHub Pages</a> using the Architect theme by <a href="https://twitter.com/jasonlong">Jason Long</a>.</footer>
    </div>


  </body>
</html>
